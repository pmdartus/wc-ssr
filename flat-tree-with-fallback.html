<html>
    <head>
        <title>Flat tree</title>
    </head>

    <body>
        <!-- Simple case -->
        <x-button shadow>
            <p>Click Me</p>
        </x-button>

        <hr>

        <!-- Slot with fallback content -->
        <x-container shadow>
            x-container
            <x-child shadow>
                x-child
                <slot fallback>
                    slot fallback
                </slot>
            </x-child>
        </x-container>
        
        <hr>

        <!-- Slot with slotted content -->
        <x-container shadow>
            x-container
            <x-child shadow>
                x-child
                <slot>
                    <template fallback-content>
                        slot fallback
                    </template>
                    slot
                </slot>
            </x-child>
        </x-container>

        <hr>

        <!-- Slot with nested slot content -->
        <x-container shadow>
            x-container
            <x-child shadow>
                x-child
                <slot>
                    <template fallback-content>
                        outer slot fallback
                    </template>
                    outer slot
                    <slot>
                        <template fallback-content>
                            inner slot fallback
                        </template>
                        inner slot
                    </slot>
                </slot>
            </x-child>
        </x-container>

        <script>
            // Create a reusable tree walker that would only match on <slot> elements and elements with a shadow 
            // attribute.
            const treeWalker = document.createTreeWalker(
                document.body, 
                NodeFilter.SHOW_ELEMENT, 
                {
                    acceptNode(el) {
                        return el.tagName === 'SLOT' || el.hasAttribute('shadow');
                    }
                },
            );

            function rehydrateTree() {
                while(treeWalker.nextNode()) {
                    const el = treeWalker.currentNode;

                    if (el.tagName === 'SLOT') {
                        // Slot elements
                        const isFallback = el.hasAttribute('fallback');

                        // If the slot content is not fallback, the nodes in the slots need to be
                        // reconnected to the right parent.
                        if (isFallback === false) {
                            const shadowRoot = el.getRootNode();
                            const hostElement = shadowRoot.host;

                            let fallbackContent;
                            let firstChild;
                            while (firstChild = el.firstChild) {
                                // If the slot has a fallback content, the generated HTML contains a
                                // template element with the fallback-content attribute. In this
                                // case we save the template content for later.
                                // All other nodes are the slotted content so we can assign them
                                // to the host element light DOM.
                                if (
                                    firstChild.nodeType === firstChild.ELEMENT_NODE && 
                                    firstChild.tagName === 'TEMPLATE' &&
                                    firstChild.hasAttribute('fallback-content')
                                ) {
                                    fallbackContent = firstChild.content;
                                    firstChild.remove();
                                } else {
                                    hostElement.appendChild(
                                        firstChild,
                                        hostElement.firstChild,
                                    );
                                }
                            }

                            // Finally once all the children of the slots are exhausted we can 
                            // reassign the fallback content to the slot if necessary.
                            if (fallbackContent !== undefined) {
                                el.appendChild(fallbackContent);
                            }
                        } else {
                            el.removeAttribute('fallback');
                        }
                        
                    } else {
                        // Elements with shadow root
                        const shadow = el.attachShadow({
                            mode: 'open',
                        });

                        // Add all the children nodes into the element shadow root.
                        while (el.firstChild) {
                            shadow.appendChild(el.firstChild, shadow.firstChild);
                        }
                        el.removeAttribute('shadow');

                        // Recursively rehydrate the element shadow root.
                        treeWalker.currentNode = el.shadowRoot;
                        rehydrateTree();
                        treeWalker.currentNode = el;
                    }
                }
            }

            rehydrateTree();
        </script>
    </body>
</html>
